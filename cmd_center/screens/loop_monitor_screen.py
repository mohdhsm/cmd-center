"""LoopMonitorScreen - Monitor automated loops and findings.

This screen provides loop monitoring with 3 modes:
- Status: View loop status and last run times
- Findings: View findings/alerts generated by loops
- History: View run history for loops
"""

from datetime import datetime, timezone
from typing import Any

import httpx
from textual.app import ComposeResult
from textual.binding import Binding
from textual.containers import Container, Horizontal, Vertical
from textual.screen import Screen
from textual.widgets import (
    Button,
    DataTable,
    Footer,
    Header,
    Label,
    Select,
    Static,
)


class LoopMonitorScreen(Screen):
    """Loop monitor screen for automation status."""

    BINDINGS = [
        Binding("1", "mode_status", "Status", show=True),
        Binding("2", "mode_findings", "Findings", show=True),
        Binding("3", "mode_history", "History", show=True),
        Binding("enter", "run_selected", "Run", show=True),
        Binding("r", "refresh", "Refresh", show=True),
        Binding("escape", "go_back", "Back"),
    ]

    CSS = """
    LoopMonitorScreen {
        layout: horizontal;
    }

    #sidebar {
        width: 22;
        background: $surface;
        padding: 1;
    }

    #sidebar Label {
        margin-bottom: 1;
    }

    #sidebar .mode-button {
        width: 100%;
        margin-bottom: 1;
    }

    #sidebar .mode-button.active {
        background: $primary;
    }

    #content {
        width: 1fr;
        padding: 1;
    }

    #mode-title {
        text-style: bold;
        margin-bottom: 1;
    }

    #stats-bar {
        margin-bottom: 1;
        color: $text-muted;
    }

    #data-table {
        height: 1fr;
    }

    .filter-section {
        margin-top: 1;
    }

    .filter-label {
        margin-bottom: 0;
    }

    /* Status colors */
    .status-completed { color: $success; }
    .status-running { color: $primary; }
    .status-failed { color: $error; }

    /* Severity colors */
    .severity-critical { color: $error; text-style: bold; }
    .severity-warning { color: $warning; }
    .severity-info { color: $primary; }
    """

    def __init__(self, api_url: str) -> None:
        super().__init__()
        self.api_url = api_url
        self.current_mode = "status"
        self.items: list[dict] = []

        # Filter states
        self.finding_severity_filter = "all"
        self.finding_target_filter = "all"
        self.history_loop_filter = "all"

    def compose(self) -> ComposeResult:
        yield Header()
        with Horizontal():
            with Vertical(id="sidebar"):
                yield Label("Mode:", classes="filter-label")
                yield Button("1 Status", id="btn-status", classes="mode-button active")
                yield Button("2 Findings", id="btn-findings", classes="mode-button")
                yield Button("3 History", id="btn-history", classes="mode-button")

                yield Label("", classes="filter-section")

                # Findings filters (hidden by default)
                with Container(id="findings-filters", classes="hidden"):
                    yield Label("Severity:", classes="filter-label")
                    yield Select(
                        [
                            ("All", "all"),
                            ("Critical", "critical"),
                            ("Warning", "warning"),
                            ("Info", "info"),
                        ],
                        id="severity-select",
                        value="all",
                    )
                    yield Label("Target:", classes="filter-label")
                    yield Select(
                        [
                            ("All", "all"),
                            ("Document", "document"),
                            ("Bonus", "bonus"),
                            ("Task", "task"),
                            ("Reminder", "reminder"),
                        ],
                        id="target-select",
                        value="all",
                    )

                # History filters (hidden by default)
                with Container(id="history-filters", classes="hidden"):
                    yield Label("Loop:", classes="filter-label")
                    yield Select(
                        [
                            ("All Loops", "all"),
                            ("docs_expiry", "docs_expiry"),
                            ("bonus_due", "bonus_due"),
                            ("task_overdue", "task_overdue"),
                            ("reminder_processing", "reminder_processing"),
                        ],
                        id="loop-select",
                        value="all",
                    )

                yield Label("", classes="filter-section")

                yield Label("Quick Stats:", classes="filter-label")
                yield Static("Today runs: —", id="stat-runs")
                yield Static("Findings: —", id="stat-findings")

                yield Label("", classes="filter-section")
                yield Button("Run All Loops", id="btn-run-all", variant="warning")
                yield Button("Refresh", id="btn-refresh", variant="primary")

            with Vertical(id="content"):
                yield Static("Loop Status", id="mode-title")
                yield Static("", id="stats-bar")
                yield DataTable(id="data-table", cursor_type="row")

        yield Footer()

    def on_mount(self) -> None:
        """Initialize the screen."""
        self._switch_mode("status")

    def _switch_mode(self, mode: str) -> None:
        """Switch between status/findings/history modes."""
        self.current_mode = mode

        # Update button states
        for btn_id in ["btn-status", "btn-findings", "btn-history"]:
            btn = self.query_one(f"#{btn_id}", Button)
            btn.remove_class("active")

        mode_btn_map = {
            "status": "btn-status",
            "findings": "btn-findings",
            "history": "btn-history",
        }
        self.query_one(f"#{mode_btn_map[mode]}", Button).add_class("active")

        # Show/hide filter sections
        self.query_one("#findings-filters", Container).add_class("hidden")
        self.query_one("#history-filters", Container).add_class("hidden")

        if mode == "findings":
            self.query_one("#findings-filters", Container).remove_class("hidden")
        elif mode == "history":
            self.query_one("#history-filters", Container).remove_class("hidden")

        # Update title
        title_map = {
            "status": "Loop Status",
            "findings": "Loop Findings",
            "history": "Run History",
        }
        self.query_one("#mode-title", Static).update(title_map[mode])

        # Reload data
        self._load_data()

    def _load_data(self) -> None:
        """Load data for current mode."""
        self.run_worker(self._fetch_data(), exclusive=True)

    async def _fetch_data(self) -> None:
        """Fetch data from API based on current mode."""
        try:
            async with httpx.AsyncClient() as client:
                if self.current_mode == "status":
                    await self._fetch_status(client)
                elif self.current_mode == "findings":
                    await self._fetch_findings(client)
                elif self.current_mode == "history":
                    await self._fetch_history(client)

                # Update quick stats
                await self._update_quick_stats(client)
        except Exception as e:
            self.query_one("#stats-bar", Static).update(f"Error: {e}")

    async def _fetch_status(self, client: httpx.AsyncClient) -> None:
        """Fetch loop status."""
        response = await client.get(f"{self.api_url}/loops/status")
        if response.status_code == 200:
            self.items = response.json()
            self._render_status()

    def _render_status(self) -> None:
        """Render loop status table."""
        table = self.query_one("#data-table", DataTable)
        table.clear(columns=True)

        table.add_columns("Loop", "Description", "Interval", "Last Run", "Status", "Findings")

        now = datetime.now(timezone.utc).replace(tzinfo=None)

        for loop in self.items:
            interval = loop.get("interval_minutes", 0)
            if interval >= 60:
                interval_str = f"{interval // 60}h"
            else:
                interval_str = f"{interval}m"

            last_run_str = "Never"
            if loop.get("last_run_at"):
                last_run = datetime.fromisoformat(
                    loop["last_run_at"].replace("Z", "")
                )
                minutes_ago = int((now - last_run).total_seconds() / 60)
                if minutes_ago < 60:
                    last_run_str = f"{minutes_ago}m ago"
                else:
                    hours_ago = minutes_ago // 60
                    last_run_str = f"{hours_ago}h ago"

            status = loop.get("last_status", "unknown")
            status_icon = {
                "completed": "OK",
                "running": "...",
                "failed": "ERR",
            }.get(status, "?")

            findings = loop.get("last_findings_count", 0)

            table.add_row(
                loop.get("name", "—"),
                (loop.get("description") or "—")[:30],
                interval_str,
                last_run_str,
                status_icon,
                str(findings),
                key=loop.get("name", ""),
            )

        self.query_one("#stats-bar", Static).update(
            f"Total: {len(self.items)} loops"
        )

    async def _fetch_findings(self, client: httpx.AsyncClient) -> None:
        """Fetch loop findings."""
        params = {}
        if self.finding_severity_filter != "all":
            params["severity"] = self.finding_severity_filter
        if self.finding_target_filter != "all":
            params["target_type"] = self.finding_target_filter

        response = await client.get(
            f"{self.api_url}/loops/findings", params=params
        )
        if response.status_code == 200:
            self.items = response.json()
            self._render_findings()

    def _render_findings(self) -> None:
        """Render findings table."""
        table = self.query_one("#data-table", DataTable)
        table.clear(columns=True)

        table.add_columns("Time", "Severity", "Loop", "Target", "Message", "Action")

        for finding in self.items:
            time_str = "—"
            if finding.get("created_at"):
                created = datetime.fromisoformat(
                    finding["created_at"].replace("Z", "")
                )
                time_str = created.strftime("%m-%d %H:%M")

            severity = finding.get("severity", "info")
            severity_icon = {
                "critical": "CRIT",
                "warning": "WARN",
                "info": "INFO",
            }.get(severity, "?")

            target = f"{finding.get('target_type', '?')}:{finding.get('target_id', '?')}"

            table.add_row(
                time_str,
                severity_icon,
                finding.get("loop_name", "—"),
                target,
                (finding.get("message") or "—")[:40],
                (finding.get("recommended_action") or "—")[:25],
                key=str(finding.get("id", "")),
            )

        self.query_one("#stats-bar", Static).update(
            f"Total: {len(self.items)} findings"
        )

    async def _fetch_history(self, client: httpx.AsyncClient) -> None:
        """Fetch run history."""
        params = {}
        if self.history_loop_filter != "all":
            params["loop_name"] = self.history_loop_filter

        response = await client.get(
            f"{self.api_url}/loops/runs", params=params
        )
        if response.status_code == 200:
            self.items = response.json()
            self._render_history()

    def _render_history(self) -> None:
        """Render run history table."""
        table = self.query_one("#data-table", DataTable)
        table.clear(columns=True)

        table.add_columns("Time", "Loop", "Duration", "Status", "Findings")

        for run in self.items:
            time_str = "—"
            if run.get("started_at"):
                started = datetime.fromisoformat(
                    run["started_at"].replace("Z", "")
                )
                time_str = started.strftime("%m-%d %H:%M")

            duration_str = "—"
            if run.get("started_at") and run.get("finished_at"):
                started = datetime.fromisoformat(
                    run["started_at"].replace("Z", "")
                )
                finished = datetime.fromisoformat(
                    run["finished_at"].replace("Z", "")
                )
                duration = (finished - started).total_seconds()
                if duration < 60:
                    duration_str = f"{duration:.1f}s"
                else:
                    duration_str = f"{duration / 60:.1f}m"

            status = run.get("status", "unknown")
            status_icon = {
                "completed": "OK",
                "running": "...",
                "failed": "ERR",
            }.get(status, "?")

            table.add_row(
                time_str,
                run.get("loop_name", "—"),
                duration_str,
                status_icon,
                str(run.get("findings_count", 0)),
                key=str(run.get("id", "")),
            )

        self.query_one("#stats-bar", Static).update(
            f"Total: {len(self.items)} runs"
        )

    async def _update_quick_stats(self, client: httpx.AsyncClient) -> None:
        """Update quick stats in sidebar."""
        try:
            # Get today's runs count
            runs_resp = await client.get(f"{self.api_url}/loops/runs")
            if runs_resp.status_code == 200:
                runs = runs_resp.json()
                today = datetime.now(timezone.utc).date()
                today_runs = sum(
                    1
                    for r in runs
                    if r.get("started_at")
                    and datetime.fromisoformat(
                        r["started_at"].replace("Z", "")
                    ).date()
                    == today
                )
                self.query_one("#stat-runs", Static).update(
                    f"Today runs: {today_runs}"
                )

            # Get findings count
            findings_resp = await client.get(f"{self.api_url}/loops/findings")
            if findings_resp.status_code == 200:
                findings = findings_resp.json()
                self.query_one("#stat-findings", Static).update(
                    f"Findings: {len(findings)}"
                )
        except Exception:
            pass

    # Event handlers
    def on_button_pressed(self, event: Button.Pressed) -> None:
        """Handle button presses."""
        button_id = event.button.id

        if button_id == "btn-status":
            self._switch_mode("status")
        elif button_id == "btn-findings":
            self._switch_mode("findings")
        elif button_id == "btn-history":
            self._switch_mode("history")
        elif button_id == "btn-refresh":
            self._load_data()
        elif button_id == "btn-run-all":
            self._run_all_loops()

    def on_select_changed(self, event: Select.Changed) -> None:
        """Handle filter selection changes."""
        select_id = event.select.id
        value = str(event.value)

        if select_id == "severity-select":
            self.finding_severity_filter = value
        elif select_id == "target-select":
            self.finding_target_filter = value
        elif select_id == "loop-select":
            self.history_loop_filter = value

        self._load_data()

    # Actions
    def action_mode_status(self) -> None:
        """Switch to status mode."""
        self._switch_mode("status")

    def action_mode_findings(self) -> None:
        """Switch to findings mode."""
        self._switch_mode("findings")

    def action_mode_history(self) -> None:
        """Switch to history mode."""
        self._switch_mode("history")

    def action_run_selected(self) -> None:
        """Run the selected loop (status mode only)."""
        if self.current_mode != "status":
            return

        table = self.query_one("#data-table", DataTable)
        if table.cursor_row is None or not self.items:
            return

        try:
            row_key = table.get_row_at(table.cursor_row)
            loop_name = row_key[0] if row_key else None
            if loop_name:
                self.run_worker(self._trigger_loop(loop_name))
        except Exception:
            pass

    def _run_all_loops(self) -> None:
        """Run all loops."""
        self.run_worker(self._trigger_all_loops())

    async def _trigger_loop(self, loop_name: str) -> None:
        """Trigger a single loop."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.api_url}/loops/{loop_name}/run"
                )
                if response.status_code == 200:
                    self.query_one("#stats-bar", Static).update(
                        f"Loop '{loop_name}' triggered successfully"
                    )
                    # Refresh after a short delay
                    self._load_data()
        except Exception as e:
            self.query_one("#stats-bar", Static).update(f"Error: {e}")

    async def _trigger_all_loops(self) -> None:
        """Trigger all loops."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(f"{self.api_url}/loops/run-all")
                if response.status_code == 200:
                    self.query_one("#stats-bar", Static).update(
                        "All loops triggered successfully"
                    )
                    self._load_data()
        except Exception as e:
            self.query_one("#stats-bar", Static).update(f"Error: {e}")

    def action_refresh(self) -> None:
        """Refresh data."""
        self._load_data()

    def action_go_back(self) -> None:
        """Go back to dashboard."""
        self.app.switch_screen("dashboard")
